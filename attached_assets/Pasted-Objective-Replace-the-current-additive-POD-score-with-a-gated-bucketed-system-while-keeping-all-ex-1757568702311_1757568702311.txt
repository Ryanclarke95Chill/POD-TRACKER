Objective Replace the current additive POD score with a gated + bucketed system while keeping all existing UI components and API shapes unchanged (cards, 100/100 banner, breakdown rows). Only adjust how the score, grade, and per-row “+pts” are computed. What to implement Gate checks (pass/fail before scoring) Implement passesGates(pod): { ok: boolean; missing: string[] }. Fail gates (non-compliant, no numeric score) if any of these are missing: Signature present Receiver name present (first name) last name or initial beneficial Temperature pickup and delivery recorded with 1 decimal (e.g., -20.5) Photos requirement: If photo-type detection exists, require 5 types: label, temp-gun reading, open-box/scan, storefront with name/number, all-stock/SKUs. If types aren’t detected yet, temporary rule: total photos ≥ 3 passes. (implement photo type detection) (Optional if available) QTY provided; if not in data, don’t gate on it. Bucketed scoring (total 100) — only after gates pass Photos (30) Mandatory set present (or ≥3 photos under temporary rule) → +25 Extra useful photos bonus: +1 each up to +5 (cap 30 total) Photo clarity/OCR (15) (feature flag; default 0 if not implemented) Label OCR/legible → +7 Temp screen legible with decimal → +5 No-blur heuristic → +3 Recipient confirmation (15) Signature → +8 Receiver name → +7 Temperature compliance (25) Pickup has 1 decimal → +5 Delivery has 1 decimal → +5 Delivery within expected band → +10 Parse expectedBandLabel like "Frozen -18C to -20C"; if unparsable, award 0 for this sub-item and add issue “Expected band missing”. Quantity accuracy (15) QTY present → +5 (If you have a boolean for matches-evidence later) → +10; otherwise 0. Cap total at 100 and cap photos bonus at +5 to avoid spamming. Grades Gold: 90–100 Silver: 75–89 Bronze: 60–74 Non-compliant: (gates failed, no numeric score) Parsing helper Create parseBandFromLabel(str) -> {min,max} | null that accepts forms like “-18C to -20C” or "0 to 5 C" (order-agnostic). Config Add config/scoring.json with: { "weights": { "photos_mandatory": 25, "photos_bonus_max": 5, "clarity_label_ocr": 7, "clarity_temp_legible": 5, "clarity_no_blur": 3, "signature": 8, "receiver_name": 7, "temp_pickup_decimal": 5, "temp_delivery_decimal": 5, "temp_in_band": 10, "qty_present": 5, "qty_matches_evidence": 10 }, "bands": { "gold": [90,100], "silver": [75,89], "bronze": [60,74] }, "featureFlags": { "clarityChecks": false } } The UI should read per-row deltas from the scoring breakdown you return. Wire-up Keep existing API response shape; only change score, grade, and breakdown values. Breakdown keys to return (match existing UI rows): "photos", "signature", "receiver_name", "temperature", "clarity", "quantity". If gates fail, return { compliant:false, grade:"Non-compliant", score:0, issues:[...missing items...] } and render your current non-compliant UI state. Acceptance tests (add or update unit tests) Gold example (like your screenshot): 4+ photos, signature, name, pickup+delivery decimals, band parsed & in-range ⇒ 100/100 with all green rows. Gate fail (no signature or name) ⇒ Non-compliant, no numeric score, issues listed. Missing decimals (e.g., -20) ⇒ gate fail with the specific missing decimal key. Missing/Unparsable expected band ⇒ gates pass, temperature bucket only awards decimal points (10), 0 for in-band, issue recorded. Photo bonus cap: 20 photos still only +5 extra. Do not change any visual styling or component layout. Only change the scoring logic and returned breakdown so the current UI displays correct numbers and messages. Deliverables New/updated scoring module (e.g., scorePod.ts + parseBandFromLabel) config/scoring.json Updated tests for the scenarios above Post-run Print a short diff summary of files changed and one sample calculation log for a passing POD and a failing POD.